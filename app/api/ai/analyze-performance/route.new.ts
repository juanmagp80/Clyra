import { NextRequest, NextResponse } from 'next/server';
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { createClient } from '@supabase/supabase-js';
import { cookies } from 'next/headers';
import OpenAI from 'openai';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

interface PerformanceAnalysisRequest {
  period: '7_days' | '30_days' | '90_days';
}

interface CalendarEvent {
  id: string;
  title: string;
  type: string;
  start_time: string;
  end_time: string;
  duration_minutes: number;
  productivity_score: number;
  actual_revenue: number;
  status: string;
  client?: { name: string; company?: string };
  project?: { name: string; status: string };
}

interface TimeTrackingSession {
  id: string;
  start_time: string;
  end_time: string;
  duration_minutes: number;
  billable_minutes: number;
  break_minutes: number;
  notes: string;
  mood_before: number;
  mood_after: number;
  energy_before: number;
  energy_after: number;
  focus_quality: number;
  interruptions: number;
  productivity_score: number;
  tasks_completed: number;
  hourly_rate: number;
  total_earned: number;
  environment_type: string;
  time_of_day: string;
  is_optimal_time: boolean;
}

interface BudgetData {
  id: string;
  title: string;
  total_amount: number;
  status: string;
  created_at: string;
  client?: { name: string };
  budget_items?: { name: string; price: number; quantity: number }[];
}

function getPeriodRange(period: string) {
  const now = new Date();
  const start = new Date();
  
  switch (period) {
    case '7_days':
      start.setDate(now.getDate() - 7);
      break;
    case '30_days':
      start.setDate(now.getDate() - 30);
      break;
    case '90_days':
      start.setDate(now.getDate() - 90);
      break;
    default:
      start.setDate(now.getDate() - 30);
  }
  
  return {
    start: start.toISOString(),
    end: now.toISOString()
  };
}

async function collectUserData(supabase: any, userId: string, period: string) {
  try {
    const dateRange = getPeriodRange(period);
    
    console.log(`üìÖ Rango de fechas para an√°lisis:`, {
      period,
      start: dateRange.start,
      end: dateRange.end
    });

    // Eventos de calendario
    const { data: calendarEvents, error: eventsError } = await supabase
      .from('calendar_events')
      .select(`
        *,
        client:clients(name, company),
        project:projects(name, status)
      `)
      .eq('user_id', userId)
      .gte('start_time', dateRange.start)
      .order('start_time', { ascending: false });

    if (eventsError) {
      console.error('‚ùå Error fetching calendar events:', eventsError);
    }

    // Sesiones de time tracking
    const { data: timeTrackingSessions, error: sessionsError } = await supabase
      .from('time_tracking_sessions')
      .select('*')
      .eq('user_id', userId)
      .gte('start_time', dateRange.start)
      .order('start_time', { ascending: false });

    if (sessionsError) {
      console.error('‚ùå Error fetching time tracking sessions:', sessionsError);
    }

    // Presupuestos y revenue
    const { data: budgetsData, error: budgetsError } = await supabase
      .from('budgets')
      .select(`
        *,
        client:clients(name),
        budget_items(*)
      `)
      .eq('user_id', userId)
      .gte('created_at', dateRange.start)
      .order('created_at', { ascending: false });

    if (budgetsError) {
      console.error('‚ùå Error fetching budgets:', budgetsError);
    }

    // Insights previos de IA
    const { data: aiInsights, error: insightsError } = await supabase
      .from('ai_insights')
      .select('*')
      .eq('user_id', userId)
      .gte('created_at', dateRange.start)
      .order('created_at', { ascending: false });

    if (insightsError) {
      console.error('‚ùå Error fetching AI insights:', insightsError);
    }

    const result = {
      calendarEvents: calendarEvents || [],
      timeTrackingSessions: timeTrackingSessions || [],
      budgetsData: budgetsData || [],
      aiInsights: aiInsights || []
    };

    console.log(`‚úÖ Datos recopilados exitosamente:`, {
      calendarEvents: result.calendarEvents.length,
      timeTrackingSessions: result.timeTrackingSessions.length,
      budgetsData: result.budgetsData.length,
      aiInsights: result.aiInsights.length
    });

    return result;
  } catch (error) {
    console.error('‚ùå Error collecting user data:', error);
    throw new Error(`Error recopilando datos: ${error instanceof Error ? error.message : 'Error desconocido'}`);
  }
}

function calculateMetrics(userData: any) {
  const { calendarEvents, timeTrackingSessions, budgetsData } = userData;
  
  // Helper function to clean NaN values
  const cleanNumber = (value: number) => isNaN(value) || !isFinite(value) ? 0 : value;
  
  // M√©tricas de time tracking
  const totalWorkHours = timeTrackingSessions.reduce((sum: number, session: TimeTrackingSession) => 
    sum + (session.duration_minutes / 60), 0);
  
  const totalBillableHours = timeTrackingSessions.reduce((sum: number, session: TimeTrackingSession) => 
    sum + (session.billable_minutes / 60), 0);
  
  const billablePercentage = totalWorkHours > 0 ? (totalBillableHours / totalWorkHours) * 100 : 0;
  
  const avgProductivity = timeTrackingSessions.length > 0 
    ? timeTrackingSessions.reduce((sum: number, session: TimeTrackingSession) => 
        sum + session.productivity_score, 0) / timeTrackingSessions.length
    : 0;
  
  // M√©tricas de revenue (desde calendar events)
  const totalRevenue = calendarEvents.reduce((sum: number, event: CalendarEvent) => 
    sum + (event.actual_revenue || 0), 0);
  
  // Si tenemos horas facturables de time tracking, usar esas; sino usar duraci√≥n de eventos
  let effectiveBillableHours = totalBillableHours;
  if (effectiveBillableHours === 0 && calendarEvents.length > 0) {
    const validEvents = calendarEvents.filter((event: CalendarEvent) => 
      event.duration_minutes && !isNaN(event.duration_minutes) && event.duration_minutes > 0);
    effectiveBillableHours = validEvents.reduce((sum: number, event: CalendarEvent) => 
      sum + (event.duration_minutes / 60), 0);
  }
  
  const revenuePerHour = effectiveBillableHours > 0 ? totalRevenue / effectiveBillableHours : 0;
  
  // M√©tricas adicionales
  const totalEvents = calendarEvents.length;
  const avgEventDuration = totalEvents > 0 
    ? calendarEvents.reduce((sum: number, event: CalendarEvent) => 
        sum + (event.duration_minutes || 0), 0) / totalEvents / 60
    : 0;
  
  const avgEventProductivity = totalEvents > 0 
    ? calendarEvents.reduce((sum: number, event: CalendarEvent) => 
        sum + (event.productivity_score || 0), 0) / totalEvents
    : 0;
  
  return {
    // Time tracking metrics
    totalWorkHours: Math.round(cleanNumber(totalWorkHours) * 100) / 100,
    totalBillableHours: Math.round(cleanNumber(totalBillableHours) * 100) / 100,
    billablePercentage: Math.round(cleanNumber(billablePercentage) * 100) / 100,
    avgProductivity: Math.round(cleanNumber(avgProductivity) * 100) / 100,
    
    // Financial metrics
    totalRevenue: Math.round(cleanNumber(totalRevenue) * 100) / 100,
    revenuePerHour: Math.round(cleanNumber(revenuePerHour) * 100) / 100,
    
    // Event metrics (fallback when no time tracking)
    totalEvents,
    avgEventDuration: Math.round(cleanNumber(avgEventDuration) * 100) / 100,
    avgEventProductivity: Math.round(cleanNumber(avgEventProductivity) * 100) / 100,
    effectiveBillableHours: Math.round(cleanNumber(effectiveBillableHours) * 100) / 100,
    
    // Data availability flags
    hasTimeTracking: timeTrackingSessions.length > 0,
    hasEvents: calendarEvents.length > 0,
    hasBudgets: budgetsData.length > 0
  };
}

async function analyzePerformanceWithAI(userData: any, period: string, metrics: any) {
  const prompt = `Analiza el rendimiento profesional de este usuario bas√°ndote en estos datos reales:

PER√çODO DE AN√ÅLISIS: ${period.replace('_', ' ')}
M√âTRICAS CALCULADAS:
- Horas trabajadas: ${metrics.totalWorkHours}h
- Horas facturables: ${metrics.totalBillableHours}h  
- % Facturable: ${metrics.billablePercentage}%
- Productividad promedio: ${metrics.avgProductivity}/10
- Revenue total: ‚Ç¨${metrics.totalRevenue}
- Revenue por hora: ‚Ç¨${metrics.revenuePerHour}

üìÖ EVENTOS DE CALENDARIO (${userData.calendarEvents.length} eventos):
${userData.calendarEvents.slice(0, 10).map((event: CalendarEvent) => `
- ${event.title} (${event.type})
- Duraci√≥n: ${event.duration_minutes}min
- Productividad: ${event.productivity_score}/10
- Cliente: ${event.client?.name || 'Sin cliente'}
- Revenue: ‚Ç¨${event.actual_revenue || 0}
`).join('')}

‚è±Ô∏è TIME TRACKING (${userData.timeTrackingSessions.length} sesiones):
${userData.timeTrackingSessions.slice(0, 10).map((session: TimeTrackingSession) => `
- Ambiente: ${session.environment_type || 'No especificado'}
- Duraci√≥n: ${session.duration_minutes}min (${session.billable_minutes}min facturables)
- Productividad: ${session.productivity_score}/10
- Energ√≠a: ${session.energy_before} ‚Üí ${session.energy_after}
- Focus: ${session.focus_quality}/5, Interrupciones: ${session.interruptions}
- Tareas completadas: ${session.tasks_completed}
- Horario: ${session.time_of_day} (√ìptimo: ${session.is_optimal_time ? 'S√≠' : 'No'})
- Revenue: ‚Ç¨${session.total_earned || 0} (‚Ç¨${session.hourly_rate || 0}/h)
`).join('')}

üí∞ PRESUPUESTOS (${userData.budgetsData.length} presupuestos):
${userData.budgetsData.map((budget: BudgetData) => `
- ${budget.title}: ‚Ç¨${budget.total_amount} (${budget.status})
- Cliente: ${budget.client?.name || 'Sin cliente'}
- Items: ${budget.budget_items?.length || 0}
`).join('')}

INSTRUCCIONES:
Proporciona an√°lisis detallado COMPLETAMENTE EN ESPA√ëOL usando esta estructura JSON exacta:

{
  "productivity_analysis": {
    "overall_score": [n√∫mero 1-10],
    "efficiency_trends": "[an√°lisis detallado en espa√±ol]",
    "peak_performance_hours": ["HH:MM-HH:MM"],
    "productivity_patterns": "[patrones identificados en espa√±ol]"
  },
  "time_management": {
    "billable_percentage": [porcentaje],
    "average_session_length": [horas],
    "break_frequency": "[an√°lisis en espa√±ol]",
    "time_distribution": {"trabajo": [%], "reuniones": [%], "admin": [%]}
  },
  "client_performance": {
    "response_time_average": "[an√°lisis en espa√±ol]",
    "satisfaction_indicators": "[indicadores en espa√±ol]",
    "communication_effectiveness": [puntuaci√≥n 1-10],
    "project_delivery_rate": [porcentaje]
  },
  "financial_performance": {
    "revenue_trend": "[tendencia en espa√±ol]",
    "revenue_per_hour": [n√∫mero],
    "proposal_conversion_rate": [porcentaje],
    "budget_accuracy": "[an√°lisis en espa√±ol]"
  },
  "bottlenecks_identified": [
    {
      "area": "[√°rea problem√°tica en espa√±ol]",
      "impact": "[alto/medio/bajo]",
      "description": "[descripci√≥n detallada en espa√±ol]",
      "solution": "[soluci√≥n propuesta en espa√±ol]"
    }
  ],
  "opportunities": [
    {
      "opportunity": "[oportunidad en espa√±ol]",
      "potential_impact": "[impacto potencial en espa√±ol]",
      "implementation": "[pasos de implementaci√≥n en espa√±ol]",
      "priority": "[alta/media/baja]"
    }
  ],
  "actionable_recommendations": [
    {
      "action": "[acci√≥n espec√≠fica en espa√±ol]",
      "expected_outcome": "[resultado esperado en espa√±ol]",
      "timeframe": "[marco temporal en espa√±ol]",
      "difficulty": "[f√°cil/medio/dif√≠cil]"
    }
  ],
  "next_period_predictions": {
    "productivity_forecast": [puntuaci√≥n proyectada 1-10],
    "revenue_projection": [cantidad en euros],
    "key_focus_areas": ["[√°rea 1 en espa√±ol]", "[√°rea 2 en espa√±ol]"]
  }
}

IMPORTANTE: 
- Todo el contenido DEBE estar en espa√±ol
- Proporciona an√°lisis espec√≠ficos basados en los datos reales
- Incluye n√∫meros y m√©tricas concretas
- Las recomendaciones deben ser accionables y espec√≠ficas`;

  try {
    console.log('ü§ñ Enviando datos a OpenAI para an√°lisis...');
    
    const completion = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        {
          role: "system",
          content: "Eres un consultor experto en productividad y an√°lisis de rendimiento profesional. Analiza datos detalladamente y proporciona insights valiosos en espa√±ol."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      response_format: { type: "json_object" },
      temperature: 0.7,
      max_tokens: 4000
    });

    const analysisContent = completion.choices[0].message.content;
    if (!analysisContent) {
      throw new Error('No se recibi√≥ respuesta de OpenAI');
    }

    console.log('‚úÖ An√°lisis completado por OpenAI');
    return JSON.parse(analysisContent);

  } catch (error) {
    console.error('‚ùå Error en an√°lisis con OpenAI:', error);
    
    // Fallback: generar an√°lisis b√°sico
    return createFallbackAnalysis(metrics, userData);
  }
}

function createFallbackAnalysis(metrics: any, userData: any) {
  const productivity_score = metrics.avgProductivity || 5.0;
  
  return {
    productivity_analysis: {
      overall_score: productivity_score,
      efficiency_trends: `An√°lisis basado en ${userData.timeTrackingSessions.length} sesiones de trabajo. Productividad promedio de ${productivity_score}/10.`,
      peak_performance_hours: ["09:00-11:00", "14:00-16:00"],
      productivity_patterns: "Patrones identificados en base a las sesiones registradas y eventos de calendario."
    },
    time_management: {
      billable_percentage: metrics.billablePercentage,
      average_session_length: userData.timeTrackingSessions.length > 0 ? 
        userData.timeTrackingSessions.reduce((sum: number, s: any) => sum + s.duration_minutes, 0) / userData.timeTrackingSessions.length / 60 : 0,
      break_frequency: metrics.billablePercentage > 80 ? "insuficiente" : metrics.billablePercentage > 60 ? "√≥ptima" : "excesiva",
      time_distribution: {"trabajo": 70, "reuniones": 20, "admin": 10}
    },
    client_performance: {
      response_time_average: "An√°lisis basado en eventos registrados",
      satisfaction_indicators: "M√©tricas de productividad y entrega positivas",
      communication_effectiveness: Math.min(10, Math.max(5, metrics.avgProductivity)),
      project_delivery_rate: 85
    },
    financial_performance: {
      revenue_trend: metrics.totalRevenue > 0 ? "positiva" : "necesita mejora",
      revenue_per_hour: metrics.revenuePerHour,
      proposal_conversion_rate: 70,
      budget_accuracy: "Basado en presupuestos activos, precisi√≥n estimada buena"
    },
    bottlenecks_identified: [
      {
        area: "Eficiencia facturable",
        impact: metrics.billablePercentage < 70 ? "alto" : "bajo",
        description: `Porcentaje facturable actual: ${metrics.billablePercentage}%`,
        solution: "Optimizar planificaci√≥n y reducir tiempo no facturable"
      }
    ],
    opportunities: [
      {
        opportunity: "Optimizaci√≥n de tarifas",
        potential_impact: `Potencial incremento de ‚Ç¨${Math.round(metrics.revenuePerHour * 0.2)}/hora`,
        implementation: "Revisar tarifas bas√°ndose en valor entregado",
        priority: "alta"
      }
    ],
    actionable_recommendations: [
      {
        action: "Implementar time blocking para trabajo de alta concentraci√≥n",
        expected_outcome: "Incremento del 15-25% en productividad",
        timeframe: "1 semana",
        difficulty: "f√°cil"
      },
      {
        action: "Automatizar reportes y comunicaciones rutinarias",
        expected_outcome: "Ahorro de 3-5 horas semanales",
        timeframe: "2-3 semanas",
        difficulty: "medio"
      }
    ],
    next_period_predictions: {
      productivity_forecast: Math.min(10, productivity_score + 0.5),
      revenue_projection: Math.round(metrics.totalRevenue * 1.1),
      key_focus_areas: ["Automatizaci√≥n", "Optimizaci√≥n de precios", "Gesti√≥n del tiempo"]
    }
  };
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { period = '30_days', userId } = body;

    let supabase = createRouteHandlerClient({ cookies });
    let user = null;
    let authError = null;

    const authResult = await supabase.auth.getUser();
    user = authResult.data?.user;
    authError = authResult.error;
    
    console.log('üîê Auth attempt 1 (Route Handler):', { 
      user: user ? { id: user.id, email: user.email } : null, 
      authError: authError?.message 
    });

    if (authError || !user) {
      console.log('üîÑ Trying alternative auth method...');
      
      const authHeader = request.headers.get('authorization');
      if (authHeader && authHeader.startsWith('Bearer ')) {
        const token = authHeader.substring(7);
        
        supabase = createClient(
          process.env.NEXT_PUBLIC_SUPABASE_URL!,
          process.env.SUPABASE_SERVICE_ROLE_KEY!
        );

        try {
          const { data: { user: jwtUser }, error: jwtError } = await supabase.auth.getUser(token);
          if (!jwtError && jwtUser) {
            user = jwtUser;
            console.log('‚úÖ Auth success with JWT token:', user.email);
          }
        } catch (jwtErr) {
          console.log('‚ùå JWT verification failed:', jwtErr);
        }
      }
    }

    if (!user && userId) {
      console.log('üîÑ Using service role with userId from body...');
      
      supabase = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.SUPABASE_SERVICE_ROLE_KEY!
      );

      user = { id: userId };
      console.log('‚úÖ Using service role for user:', userId);
    }
    
    if (!user) {
      console.error('‚ùå All auth methods failed');
      return NextResponse.json({ 
        error: 'No se pudo autenticar el usuario. Por favor, cierra sesi√≥n y vuelve a iniciar sesi√≥n.' 
      }, { status: 401 });
    }

    console.log(`üîç Iniciando an√°lisis de rendimiento para usuario ${user.id}, per√≠odo: ${period}`);

    const userData = await collectUserData(supabase, user.id, period);
    
    console.log(`üìä Datos recopilados:`, {
      calendarEvents: userData.calendarEvents.length,
      timeTrackingSessions: userData.timeTrackingSessions.length,
      budgets: userData.budgetsData.length,
      insights: userData.aiInsights.length
    });

    const totalDataPoints = userData.calendarEvents.length + userData.timeTrackingSessions.length + userData.budgetsData.length;
    
    if (totalDataPoints === 0) {
      console.log('‚ö†Ô∏è No hay datos suficientes para an√°lisis, generando an√°lisis b√°sico');
      
      const basicAnalysis = {
        success: true,
        period,
        analysis: {
          productivity_analysis: {
            overall_score: 5.0,
            efficiency_trends: `No hay datos suficientes para el per√≠odo de ${period.replace('_', ' ')}. Se recomienda empezar a registrar eventos de calendario y sesiones de trabajo.`,
            peak_performance_hours: ["09:00-11:00", "14:00-16:00"],
            productivity_patterns: "Sin datos suficientes para identificar patrones."
          },
          bottlenecks_identified: [{
            area: "Falta de datos",
            impact: "alto",
            description: "No hay suficientes datos para realizar un an√°lisis detallado.",
            solution: "Comenzar a registrar actividades diarias en el calendario y sistema de time tracking."
          }],
          opportunities: [{
            opportunity: "Establecer sistema de seguimiento",
            potential_impact: "Mejor visibilidad del rendimiento",
            implementation: "Configurar tracking de tiempo y eventos de calendario",
            priority: "alta"
          }],
          actionable_recommendations: [{
            action: "Configurar sistema de tracking b√°sico",
            expected_outcome: "Datos para an√°lisis futuro",
            timeframe: "1 semana",
            difficulty: "f√°cil"
          }]
        },
        metrics: {
          totalWorkHours: 0,
          totalBillableHours: 0,
          billablePercentage: 0,
          avgProductivity: 0,
          totalRevenue: 0,
          revenuePerHour: 0
        }
      };

      return NextResponse.json(basicAnalysis);
    }

    const metrics = calculateMetrics(userData);
    
    console.log(`üìà M√©tricas calculadas:`, metrics);

    const analysis = await analyzePerformanceWithAI(userData, period, metrics);

    const { error: insertError } = await supabase
      .from('ai_insights')
      .insert({
        user_id: user.id,
        insight_type: 'performance_analysis',
        category: 'productivity',
        title: `An√°lisis de Rendimiento - ${period.replace('_', ' ')}`,
        description: `An√°lisis autom√°tico de productividad y rendimiento para el per√≠odo de ${period.replace('_', ' ')}`,
        confidence_score: 0.85,
        data_points: analysis,
        impact_score: analysis.productivity_analysis?.overall_score || 5,
        actionable: true,
        priority: 'medium',
        tags: ['productividad', 'an√°lisis', 'rendimiento', 'automatizado'],
        metadata: {
          period_analyzed: period,
          data_sources: ['calendar_events', 'time_tracking_sessions', 'budgets'],
          metrics_calculated: metrics,
          analysis_method: 'openai_gpt4_performance_analyzer'
        },
        recommendations: analysis.actionable_recommendations?.map((rec: any) => rec.action) || [],
        suggested_actions: {
          priority_actions: analysis.actionable_recommendations?.filter((rec: any) => rec.difficulty === 'f√°cil').slice(0, 3) || [],
          bottlenecks_to_address: analysis.bottlenecks_identified || [],
          opportunities: analysis.opportunities || []
        },
        status: 'new',
        time_period_start: new Date(getPeriodRange(period).start),
        time_period_end: new Date(getPeriodRange(period).end),
        auto_generated: true,
        generation_algorithm: 'openai_gpt4_performance_analyzer',
        triggers_used: ['scheduled_analysis', 'manual_request'],
        created_at: new Date().toISOString()
      });

    if (insertError) {
      console.error('Error guardando insights:', insertError);
    }

    const response = {
      success: true,
      period,
      analysis,
      metrics,
      summary: {
        overall_score: analysis.productivity_analysis.overall_score,
        key_metrics: {
          productivity: analysis.productivity_analysis.overall_score,
          efficiency: analysis.time_management.billable_percentage,
          revenue_per_hour: analysis.financial_performance.revenue_per_hour,
          communication: analysis.client_performance.communication_effectiveness
        },
        data_points: {
          calendar_events: userData.calendarEvents.length,
          tracking_sessions: userData.timeTrackingSessions.length,
          budgets: userData.budgetsData.length
        }
      },
      generated_at: new Date().toISOString()
    };

    return NextResponse.json(response);

  } catch (error) {
    console.error('Error en an√°lisis de rendimiento:', error);
    return NextResponse.json(
      { 
        error: 'Error interno del servidor',
        details: process.env.NODE_ENV === 'development' ? error : undefined
      }, 
      { status: 500 }
    );
  }
}
